#!/usr/bin/env python


from queue import Queue
from typing import Any
from builtins import None


class FifoQueueOfStacks(object):
    """FIFO queue made out of two stacks.
    
    This queue has an enqueue efficiency of O(1), but a worst-case
    dequeue efficiency of O(n) where n is the number of items currently in the
    queue.
    
    Unlike Python's built-in queue class, this implementation of a queue is not
    thread safe.
    """
    
    def __init__(self) -> None:
        self.input_stack = []
        self.output_stack = []
    
    def enqueue(self, el: Any) -> None:
        """Enqueue an element.
        
        Arguments:
            el: Any
                The element to enqueue
        """
        self.input_stack.append(el)
    
    def dequeue(self) -> Any:
        """Dequeue the next element.
        
        Returns:
            Any: The earliest element that was enqueued
            
        Raises:
            IndexError:
                if the queue is empty
        """
        if len(self.output_stack) > 0:
            return self.output_stack.pop()
        while len(self.input_stack) > 0:
            self.output_stack.append(self.input_stack.pop())
        return self.output_stack.pop()
    
    def size(self) -> int:
        """Get the size of the queue.
        
        Returns:
            int: The size of the queue
        """
        return len(self.input_stack) + len(self.output_stack)


class StackOfQueues(object):
    """Stack made out of two queues.
    
    This stack has a push efficiency of O(1) and a worse case pop efficiency of
    O(n) where n is the number of elements in the stack.
    
    This stack is not thread safe.
    """
    
    def __init__(self) -> None:
        self.input_queue = Queue()
        self.output_queue = Queue()
        
    def push(self, el: Any) -> None:
        """Push an element onto the stack.
        
        Arguments:
            el: Any
                The element to push onto the stack.
        """
        self.input_queue.put(el)
    
    def pop(self) -> Any:
        """Pop an element from the stack.
        
        Returns:
            Any: The latest element that was pushed onto the stack
        
        Raises:
            Empty: If the stack is empty
        """
        while self.input_queue.qsize() > 1:
            self.output_queue.put(self.input_queue.get())
        while not self.output_queue.empty():
            self.input_queue.put(self.output_queue.get())
        return self.input_queue.get_nowait()
    
    def size(self) -> int:
        """Get the size of the stack.
        
        Returns:
            int: The size of the stack
        """
        return self.input_queue.qsize() + self.output_queue.qsize()

class FifoQueueOfLinkedList(object):
    
    class Node(object):
        
        def __init__(self, value, predecessor, successor):
            self.value = value
            self.predecessor = predecessor
            self.successor = successor

    def __init__(self):
        self.tail = Node(None, None, None)
        self.head = Node(None, None, self.tail)
        self.tail.predecessor = self.head
        
    def enqueue(self, el):
        self.head.successor = Node(el, self.head, self.head.successor)
        
    def dequeue(self):
        el = self.tail.predecessor.value
        self.tail.predecessor = self.tail.predecessor.predecessor
        self.tail.predecessor.successor = self.tail
        return el

if __name__ == '__main__':
    # Problem 1:
    # Create a FIFO queue using only stacks.
    input = ['a', 'b', 'c']
    output = []
    queue = FifoQueueOfStacks()
    for item in input:
        queue.enqueue(item)
    while queue.size() > 0:
        output.append(queue.dequeue())
    print('Problem #1:\nInput order:\t{}\nOutput order:\t{}'.format(
        input, output))
    
    # Problem 2:
    # Create a stack using only FIFO queues.
    input = ['a', 'b', 'c']
    output = []
    stack = StackOfQueues()
    for item in input:
        stack.push(item)
    while stack.size() > 0:
        output.append(stack.pop())
    print('Problem #2:\nInput order:\t{}\nOutput order:\t{}'.format(
        input, output))
    
    # Problem 3:
    # Implement a FIFO queue using a doubly linked list.
    
    # Problem 4:
    # Implement a doubly linked list.
    pass